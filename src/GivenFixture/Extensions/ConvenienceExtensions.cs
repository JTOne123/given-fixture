using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;
using Autofac.Core;
using AutoFixture;
using AutoFixture.Dsl;
using Bogus;
using Moq;

namespace GivenFixture.Extensions
{
    /// <summary>
    /// Convenience extensions for <see cref="ITestFixture"/>.
    /// </summary>
    public static class ConvenienceExtensions
    {
        /// <summary>
        /// Adds the specified property value to the specified key.
        /// </summary>
        /// <param name="fixture">The fixture.</param>
        /// <param name="key">The key.</param>
        /// <param name="value">The value.</param>
        /// <returns></returns>
        public static ITestFixture HavingProperty<TValue>(this ITestFixture fixture, string key, TValue value)
        {
            fixture.Properties[key] = value;
            return fixture;
        }

        /// <summary>
        /// Adds the property value generated by the specified factory to the specified key.
        /// </summary>
        /// <param name="fixture">The fixture.</param>
        /// <param name="key">The key.</param>
        /// <param name="valueFactory">The value factory.</param>
        /// <returns></returns>
        public static ITestFixture HavingProperty<TValue>(this ITestFixture fixture, string key, Func<TValue> valueFactory) =>
            fixture.HavingProperty(key, valueFactory());

        /// <summary>
        /// Runs the specified fixture action if a property exists in the fixture that matches the specified value predicate.
        /// </summary>
        /// <param name="fixture">The fixture.</param>
        /// <param name="key">The key.</param>
        /// <param name="valuePredicate">The value predicate.</param>
        /// <param name="action">The action.</param>
        /// <returns></returns>
        public static ITestFixture WhenHavingProperty<TValue>(this ITestFixture fixture,
                                                              string key,
                                                              Func<TValue, bool> valuePredicate,
                                                              Action<ITestFixture> action)
        {
            if (fixture.Properties.TryGetValue(key, out var value) && value is TValue v && valuePredicate(v))
            {
                action(fixture);
            }

            return fixture;
        }

        /// <summary>
        /// Runs the specified fixture action if a property exists in the fixture that matches the specified value.
        /// </summary>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="key">The key.</param>
        /// <param name="value">The value.</param>
        /// <param name="action">The action.</param>
        /// <returns></returns>
        public static ITestFixture WhenHavingProperty<TValue>(this ITestFixture fixture,
                                                              string key,
                                                              TValue value,
                                                              Action<ITestFixture> action) =>
            fixture.WhenHavingProperty<TValue>(key, v => v.Equals(value), action);

        /// <summary>
        /// Runs the specified fixture action if a property exists in the fixture that matches the specified value predicate.
        /// </summary>
        /// <param name="fixture">The fixture.</param>
        /// <param name="key">The key.</param>
        /// <param name="valuePredicate">The value predicate.</param>
        /// <param name="action">The action.</param>
        /// <returns></returns>
        public static ITestFixture WhenHavingStringProperty(this ITestFixture fixture,
                                                            string key,
                                                            Func<string, bool> valuePredicate,
                                                            Action<ITestFixture> action) =>
            fixture.WhenHavingProperty(key, valuePredicate, action);

        /// <summary>
        /// Runs the specified fixture action if a property exists in the fixture that matches the specified value.
        /// </summary>
        /// <param name="fixture">The fixture.</param>
        /// <param name="key">The key.</param>
        /// <param name="value">The value.</param>
        /// <param name="action">The action.</param>
        /// <returns></returns>
        public static ITestFixture WhenHavingStringProperty(this ITestFixture fixture,
                                                            string key,
                                                            string value,
                                                            Action<ITestFixture> action) =>
            fixture.WhenHavingStringProperty(key, x => x == value, action);

        /// <summary>
        /// Performs an arrange action.
        /// </summary>
        /// <param name="fixture">The fixture.</param>
        /// <param name="action">The action.</param>
        /// <returns></returns>
        public static ITestFixture Having(this ITestFixture fixture, Action action)
        {
            action();
            return fixture;
        }

        /// <summary>
        /// Picks a random model from the specified collection.
        /// </summary>
        /// <typeparam name="TModel">The type of the model.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="models">The models.</param>
        /// <param name="model">The model.</param>
        /// <returns></returns>
        public static ITestFixture HavingRandom<TModel>(this ITestFixture fixture,
                                                        ICollection<TModel> models,
                                                        out TModel model)
        {
            model = fixture.Faker.Random.CollectionItem(models);
            return fixture;
        }

        /// <summary>
        /// Configures a mock of the specified type.
        /// </summary>
        /// <typeparam name="TService">The type of the service.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="mockAction">The mock action.</param>
        /// <returns></returns>
        public static ITestFixture HavingMock<TService>(this ITestFixture fixture,
                                                        Action<Mock<TService>> mockAction)
            where TService : class
        {
            var mock = fixture.AutoMock.Mock<TService>();
            mockAction(mock);
            return fixture;
        }

        /// <summary>
        /// Gets a mocked object of the specified type
        /// </summary>
        /// <typeparam name="TService">The type of the service.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="service">The service.</param>
        /// <returns></returns>
        public static ITestFixture HavingMock<TService>(this ITestFixture fixture, out TService service)
            where TService : class
        {
            service = fixture.AutoMock.Mock<TService>().Object;
            return fixture;
        }

        /// <summary>
        /// Configures a mock of the specified type to setup a call matching the specified expression to return the specified result.
        /// </summary>
        /// <typeparam name="TService">The type of the service.</typeparam>
        /// <typeparam name="TResult">The type of the result.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="expression">The expression.</param>
        /// <param name="result">The result.</param>
        /// <param name="because">The because.</param>
        /// <returns></returns>
        public static ITestFixture HavingMocked<TService, TResult>(this ITestFixture fixture,
                                                                   Expression<Func<TService, Task<TResult>>> expression,
                                                                   TResult result,
                                                                   string because = null)
            where TService : class =>
            fixture.HavingMock<TService>(m => m.Setup(expression).ReturnsAsync(result).Verifiable(because));
        
        /// <summary>
        /// Configures a mock of the specified type to setup a call matching the specified expression to return the specified result.
        /// </summary>
        /// <typeparam name="TService">The type of the service.</typeparam>
        /// <typeparam name="TResult">The type of the result.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="expression">The expression.</param>
        /// <param name="result">The result.</param>
        /// <param name="because">The because.</param>
        /// <returns></returns>
        public static ITestFixture HavingMocked<TService, TResult>(this ITestFixture fixture,
                                                                   Expression<Func<TService, TResult>> expression,
                                                                   TResult result,
                                                                   string because = null)
            where TService : class =>
            fixture.HavingMock<TService>(m => m.Setup(expression).Returns(result).Verifiable(because));
        
        /// <summary>
        /// Configures a mock of the specified type to setup a call matching the specified expression.
        /// </summary>
        /// <typeparam name="TService">The type of the service.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="expression">The expression.</param>
        /// <param name="because">The because.</param>
        /// <returns></returns>
        public static ITestFixture HavingMocked<TService>(this ITestFixture fixture,
                                                          Expression<Action<TService>> expression,
                                                          string because = null)
            where TService : class =>
            fixture.HavingMock<TService>(m => m.Setup(expression).Verifiable(because));

        /// <summary>
        /// Configures a mock of the specified type to setup a call matching the specified expression to return a completed task.
        /// </summary>
        /// <typeparam name="TService">The type of the service.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="expression">The expression.</param>
        /// <param name="because">The because.</param>
        /// <returns></returns>
        public static ITestFixture HavingMocked<TService>(this ITestFixture fixture,
                                                          Expression<Func<TService, Task>> expression,
                                                          string because = null)
            where TService : class =>
            fixture.HavingMock<TService>(m => m.Setup(expression).Returns(Task.CompletedTask).Verifiable(because));

        /// <summary>
        /// Creates an auto fixture constructed instance of the specified model.
        /// </summary>
        /// <typeparam name="TModel">The type of the model.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="model">The model.</param>
        /// <param name="composer">The composer.</param>
        /// <returns></returns>
        public static ITestFixture HavingModel<TModel>(this ITestFixture fixture,
                                                       out TModel model,
                                                       Func<IPostprocessComposer<TModel>, IPostprocessComposer<TModel>> composer = null)
        {
            model = fixture.GetComposer(composer).Create();
            return fixture;
        }

        /// <summary>
        /// Creates a collection of auto fixture constructed instances of the specified model.
        /// </summary>
        /// <typeparam name="TModel">The type of the model.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="models">The models.</param>
        /// <param name="composer">The composer.</param>
        /// <returns></returns>
        public static ITestFixture HavingModels<TModel>(this ITestFixture fixture,
                                                        out ICollection<TModel> models,
                                                        Func<IPostprocessComposer<TModel>, IPostprocessComposer<TModel>> composer = null)
        {
            models = fixture.GetComposer(composer).CreateMany().ToList();
            return fixture;
        }

        /// <summary>
        /// Uses the faker on the fixture as a factory for some fake data.
        /// </summary>
        /// <typeparam name="TFake">The type of the fake.</typeparam>
        /// <param name="fixture">The fixture.</param>
        /// <param name="factory">The factory.</param>
        /// <param name="fake">The fake.</param>
        /// <returns></returns>
        public static ITestFixture HavingFake<TFake>(this ITestFixture fixture, Func<Faker, TFake> factory, out TFake fake)
        {
            fake = factory(fixture.Faker);
            return fixture;
        }

        private static IPostprocessComposer<TModel> GetComposer<TModel>(this ITestFixture fixture, 
                                                                        Func<IPostprocessComposer<TModel>, IPostprocessComposer<TModel>> composer)
        {
            var builder = fixture.AutoFixture.Build<TModel>();
            return composer == null ? builder : composer(builder);
        }
    }
}
